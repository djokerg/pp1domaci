

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

nonterminal Program Program;
nonterminal NamespaceList NamespaceList;
nonterminal Namespace Namespace;
nonterminal MethodDeclList MethodDeclList;
nonterminal MethodDecl MethodDecl;
nonterminal TypeOrVoid TypeOrVoid;
nonterminal PossibleFormPars PossibleFormPars;
nonterminal FormPars FormPars;
nonterminal PossibleArrayDecl PossibleArrayDecl;
nonterminal DeclarationList DeclarationList;
nonterminal VarDeclList VarDeclList;
nonterminal VarDecl VarDecl;
nonterminal MultipleVarDecl MultipleVarDecl;
nonterminal Type Type;
nonterminal OptionalNamespace OptionalNamespace;
nonterminal ConstDecl ConstDecl;
nonterminal MultipleConstDecl MultipleConstDecl;
nonterminal Literal Literal;
nonterminal StaticInitializer StaticInitializer;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal Operation Operation;
nonterminal ActPars ActPars;
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal Expr Expr;
nonterminal TermList TermList;
nonterminal Term Term;
nonterminal Factor Factor;
nonterminal Designator Designator;
nonterminal DesignatorHelperList DesignatorHelperList;
nonterminal Label Label;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;

nonterminal ClassDecl ClassDecl;
terminal PROG, IDENT, NAMESPACE, LBRACE, RBRACE;
terminal BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ,RETURN, VOID, EXTENDS, CONTINUE, FOR, STATIC;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, NOTEQUAL, GRT, GRTE, LSS, LSSE, BITAND, BITOR, ASSIGN, PLUSPLUS, MINUSMINUS;
terminal SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE, LAMBDA;

terminal NUMCONST, CHARCONST, BOOLCONST;

precedence left ELSE;

Program ::= PROG IDENT NamespaceList:N1 DeclarationList:D2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new ProgramDerived1(N1, D2, M3); RESULT.setLine(N1left); :};

NamespaceList ::= NamespaceList:N1 Namespace:N2 {: RESULT=new NamespaceListDerived1(N1, N2); RESULT.setLine(N1left); :}
                | {: RESULT=new NamespaceListDerived2(); :}
                /* epsilon */
                ;

Namespace ::= NAMESPACE IDENT LBRACE DeclarationList:D1 LBRACE MethodDeclList:M2 RBRACE RBRACE {: RESULT=new NamespaceDerived1(D1, M2); RESULT.setLine(D1left); :};

MethodDeclList ::= MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListDerived1(M1, M2); RESULT.setLine(M1left); :}
                | {: RESULT=new MethodDeclListDerived2(); :}
                /* epsilon */
                ;

MethodDecl ::= TypeOrVoid:T1 IDENT LPAREN PossibleFormPars:P2 RPAREN VarDeclList:V3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDeclDerived1(T1, P2, V3, S4); RESULT.setLine(T1left); :};

TypeOrVoid ::= Type:T1 {: RESULT=new TypeOrVoidDerived1(T1); RESULT.setLine(T1left); :} | VOID {: RESULT=new TypeOrVoidDerived2(); :};

PossibleFormPars ::= FormPars:F1 {: RESULT=new PossibleFormParsDerived1(F1); RESULT.setLine(F1left); :} | {: RESULT=new PossibleFormParsDerived2(); :} /* epsilon */;

FormPars ::= FormPars:F1 COMMA Type:T2 IDENT PossibleArrayDecl:P3 {: RESULT=new FormParsDerived1(F1, T2, P3); RESULT.setLine(F1left); :}
            |
            Type:T1 IDENT PossibleArrayDecl:P2 {: RESULT=new FormParsDerived2(T1, P2); RESULT.setLine(T1left); :}
            ;

PossibleArrayDecl ::= LSQUARE RSQUARE {: RESULT=new PossibleArrayDeclDerived1(); :} | {: RESULT=new PossibleArrayDeclDerived2(); :} /* epislon */;

DeclarationList ::= DeclarationList:D1 VarDecl:V2 {: RESULT=new DeclarationListDerived1(D1, V2); RESULT.setLine(D1left); :}
			|
			DeclarationList:D1 ConstDecl:C2 {: RESULT=new DeclarationListDerived2(D1, C2); RESULT.setLine(D1left); :}
			|
			DeclarationList:D1 ClassDecl:C2 {: RESULT=new DeclarationListDerived3(D1, C2); RESULT.setLine(D1left); :}
			| {: RESULT=new DeclarationListDerived4(); :}
			/* epsilon */
			;
VarDeclList ::= VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclListDerived1(V1, V2); RESULT.setLine(V1left); :}
                | {: RESULT=new VarDeclListDerived2(); :}
                /* epsilon */
                ;

VarDecl ::= Type:T1 IDENT MultipleVarDecl:M2 SEMI {: RESULT=new VarDeclDerived1(T1, M2); RESULT.setLine(T1left); :}
        |
        Type:T1 IDENT LSQUARE RSQUARE MultipleVarDecl:M2 SEMI {: RESULT=new VarDeclDerived2(T1, M2); RESULT.setLine(T1left); :}
        ;

MultipleVarDecl ::= MultipleVarDecl:M1 COMMA IDENT {: RESULT=new MultipleVarDeclDerived1(M1); RESULT.setLine(M1left); :}
                |
                MultipleVarDecl:M1 COMMA IDENT LSQUARE RSQUARE {: RESULT=new MultipleVarDeclDerived2(M1); RESULT.setLine(M1left); :}
                | {: RESULT=new MultipleVarDeclDerived3(); :}
                /* epsilon */
                ;

Type ::= IDENT COLON COLON IDENT {: RESULT=new TypeDerived1(); :}
        |
        IDENT {: RESULT=new TypeDerived2(); :};

ConstDecl ::= CONST Type:T1 IDENT ASSIGN Literal:L2 MultipleConstDecl:M3 SEMI {: RESULT=new ConstDeclDerived1(T1, L2, M3); RESULT.setLine(T1left); :};

MultipleConstDecl ::= MultipleConstDecl:M1 COMMA IDENT ASSIGN Literal:L2 {: RESULT=new MultipleConstDeclDerived1(M1, L2); RESULT.setLine(M1left); :}
                    | {: RESULT=new MultipleConstDeclDerived2(); :}
                    /* epsilon */
                    ;

Literal ::= NUMCONST {: RESULT=new LiteralDerived1(); :} | BOOLCONST {: RESULT=new LiteralDerived2(); :} | CHARCONST {: RESULT=new LiteralDerived3(); :};

StaticInitializer ::= STATIC LBRACE StatementList:S1 RBRACE {: RESULT=new StaticInitializerDerived1(S1); RESULT.setLine(S1left); :};//mozda bude bacalo konflikt

StatementList ::= StatementList:S1 Statement:S2 {: RESULT=new StatementListDerived1(S1, S2); RESULT.setLine(S1left); :}
                | {: RESULT=new StatementListDerived2(); :}
                /* epsilon */
                ;

Statement ::= DesignatorStatement:D1 SEMI {: RESULT=new StatementDerived1(D1); RESULT.setLine(D1left); :}
            |
            IF LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new StatementDerived2(C1, S2); RESULT.setLine(C1left); :}
            |
            IF LPAREN Condition:C1 RPAREN Statement:S2 ELSE Statement:S3 {: RESULT=new StatementDerived3(C1, S2, S3); RESULT.setLine(C1left); :}
            |
            BREAK SEMI {: RESULT=new StatementDerived4(); :}
            |
            CONTINUE SEMI {: RESULT=new StatementDerived5(); :}
            |
            RETURN SEMI {: RESULT=new StatementDerived6(); :}
            |
            RETURN Expr:E1 SEMI {: RESULT=new StatementDerived7(E1); RESULT.setLine(E1left); :}
            |
            READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatementDerived8(D1); RESULT.setLine(D1left); :}
            |
            PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new StatementDerived9(E1); RESULT.setLine(E1left); :}
            |
            PRINT LPAREN Expr:E1 COMMA NUMCONST RPAREN SEMI {: RESULT=new StatementDerived10(E1); RESULT.setLine(E1left); :}
            |
            LBRACE StatementList:S1 RBRACE {: RESULT=new StatementDerived11(S1); RESULT.setLine(S1left); :}
            ;

DesignatorStatement ::= Designator:D1 Operation:O2 {: RESULT=new DesignatorStatementDerived1(D1, O2); RESULT.setLine(D1left); :};

Operation ::= Assignop:A1 Expr:E2 {: RESULT=new OperationDerived1(A1, E2); RESULT.setLine(A1left); :}
            |
            LPAREN RPAREN {: RESULT=new OperationDerived2(); :}
            |
            LPAREN ActPars:A1 RPAREN {: RESULT=new OperationDerived3(A1); RESULT.setLine(A1left); :}
            |
            PLUSPLUS {: RESULT=new OperationDerived4(); :}
            |
            MINUSMINUS {: RESULT=new OperationDerived5(); :}
            ;

ActPars ::= ActPars:A1 COMMA Expr:E2 {: RESULT=new ActParsDerived1(A1, E2); RESULT.setLine(A1left); :}
        |
        Expr:E1 {: RESULT=new ActParsDerived2(E1); RESULT.setLine(E1left); :}
        ;

Condition ::= Condition:C1 BITOR CondTerm:C2 {: RESULT=new ConditionDerived1(C1, C2); RESULT.setLine(C1left); :}
            |
            CondTerm:C1 {: RESULT=new ConditionDerived2(C1); RESULT.setLine(C1left); :}
            ;

CondTerm ::= CondTerm:C1 BITAND CondFact:C2 {: RESULT=new CondTermDerived1(C1, C2); RESULT.setLine(C1left); :}
            |
            CondFact:C1 {: RESULT=new CondTermDerived2(C1); RESULT.setLine(C1left); :}
            ;

CondFact ::= Expr:E1 {: RESULT=new CondFactDerived1(E1); RESULT.setLine(E1left); :}
            |
            Expr:E1 Relop:R2 Expr:E3 {: RESULT=new CondFactDerived2(E1, R2, E3); RESULT.setLine(E1left); :}
            ;

Expr ::= MINUS Term:T1 TermList:T2 {: RESULT=new ExprDerived1(T1, T2); RESULT.setLine(T1left); :}
        |
        Term:T1 TermList:T2 {: RESULT=new ExprDerived2(T1, T2); RESULT.setLine(T1left); :}
        ;

TermList ::= TermList:T1 Addop:A2 Term:T3 {: RESULT=new TermListDerived1(T1, A2, T3); RESULT.setLine(T1left); :}
            | {: RESULT=new TermListDerived2(); :}
            /* epsilon */
            ;

Term ::= Term:T1 Mulop:M2 Factor:F3 {: RESULT=new TermDerived1(T1, M2, F3); RESULT.setLine(T1left); :}
        |
        Factor:F1 {: RESULT=new TermDerived2(F1); RESULT.setLine(F1left); :}
        ;

Factor ::= Designator:D1 {: RESULT=new FactorDerived1(D1); RESULT.setLine(D1left); :}
        |
        Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new FactorDerived2(D1, A2); RESULT.setLine(D1left); :}
        |
        Designator:D1 LPAREN RPAREN {: RESULT=new FactorDerived3(D1); RESULT.setLine(D1left); :}
        |
        NUMCONST {: RESULT=new FactorDerived4(); :}
        |
        CHARCONST {: RESULT=new FactorDerived5(); :}
        |
        BOOLCONST {: RESULT=new FactorDerived6(); :}
        |
        NEW Type:T1 LSQUARE Expr:E2 RSQUARE {: RESULT=new FactorDerived7(T1, E2); RESULT.setLine(T1left); :}
        |
        NEW Type:T1 LSQUARE RSQUARE {: RESULT=new FactorDerived8(T1); RESULT.setLine(T1left); :}
        |
        NEW Type:T1 LPAREN ActPars:A2 RPAREN {: RESULT=new FactorDerived9(T1, A2); RESULT.setLine(T1left); :}
        |
        NEW Type:T1 LPAREN RPAREN {: RESULT=new FactorDerived10(T1); RESULT.setLine(T1left); :}
        |
        LPAREN Expr:E1 RPAREN {: RESULT=new FactorDerived11(E1); RESULT.setLine(E1left); :}
        ;

Designator ::= IDENT COLON COLON IDENT DesignatorHelperList:D1 {: RESULT=new DesignatorDerived1(D1); RESULT.setLine(D1left); :}
            |
            IDENT DesignatorHelperList:D1 {: RESULT=new DesignatorDerived2(D1); RESULT.setLine(D1left); :}
            ;

DesignatorHelperList ::= DesignatorHelperList:D1 DOT IDENT {: RESULT=new DesignatorHelperListDerived1(D1); RESULT.setLine(D1left); :}
                    |
                    DesignatorHelperList:D1 LSQUARE Expr:E2 RSQUARE {: RESULT=new DesignatorHelperListDerived2(D1, E2); RESULT.setLine(D1left); :}
                    | {: RESULT=new DesignatorHelperListDerived3(); :}
                    /* epsilon */
                    ;

Label ::= IDENT {: RESULT=new LabelDerived1(); :};

Assignop ::= ASSIGN {: RESULT=new AssignopDerived1(); :};

Relop ::= EQUAL {: RESULT=new RelopDerived1(); :} | NOTEQUAL {: RESULT=new RelopDerived2(); :} | GRT {: RESULT=new RelopDerived3(); :} | GRTE {: RESULT=new RelopDerived4(); :} | LSS {: RESULT=new RelopDerived5(); :} | LSSE {: RESULT=new RelopDerived6(); :};

Addop ::= PLUS {: RESULT=new AddopDerived1(); :} | MINUS {: RESULT=new AddopDerived2(); :};

Mulop ::= MUL {: RESULT=new MulopDerived1(); :} | DIV {: RESULT=new MulopDerived2(); :} | MOD {: RESULT=new MulopDerived3(); :} ;






