

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;
import java.lang.Boolean;

parser code {:

    boolean errorDetected;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with {:
    errorDetected = false;
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

nonterminal NamespaceList NamespaceList;
nonterminal Namespace Namespace;
nonterminal MethodDeclList MethodDeclList;
nonterminal PossibleFormPars PossibleFormPars;
nonterminal FormPars FormPars;
nonterminal PossibleArrayDecl PossibleArrayDecl;
nonterminal DeclarationList DeclarationList;
nonterminal VarDeclList VarDeclList;
nonterminal VarDecl VarDecl;
nonterminal ConstDecl ConstDecl;
nonterminal MultipleConstDecl MultipleConstDecl;
nonterminal StaticInitializer StaticInitializer;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ActPars ActPars;
nonterminal Label Label;
nonterminal Assignop Assignop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal DesStmtHelper DesStmtHelper;

nonterminal PossibleDesignatorStatementList PossibleDesignatorStatementList;
nonterminal PossibleCondFact PossibleCondFact;
nonterminal MultipleVarDecl MultipleVarDecl;
nonterminal SingleVar SingleVar;
nonterminal ClassDecl ClassDecl;
nonterminal OptionalExtends OptionalExtends;
nonterminal StaticVarDeclList StaticVarDeclList;
nonterminal StaticInitializerList StaticInitializerList;
nonterminal OtpionalMethodDeclList OtpionalMethodDeclList;
nonterminal StaticInitializerHelper StaticInitializerHelper;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, Literal, MethodDecl, MethodTypeName, Designator;
nonterminal NamespaceName NamespaceName;
nonterminal FactorCallPossiblePars FactorCallPossiblePars;
nonterminal FormParam FormParam;
nonterminal ForLoopStart ForLoopStart;
nonterminal PossibleDesignator PossibleDesignator;
nonterminal DesignatorArrayName DesignatorArrayName;
nonterminal StatementListDetected StatementListDetected;
nonterminal ForConditionStart ForConditionStart;
nonterminal ForTailDesignatorStart ForTailDesignatorStart;
nonterminal ForStatementsStart ForStatementsStart;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Expr, Term, Factor, Condition, CondTerm, CondFact;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Relop;

nonterminal IfStartDetected IfStartDetected;
nonterminal ORBlockDetected ORBlockDetected;
nonterminal IfConditionEndDetected IfConditionEndDetected;
nonterminal IfBlock IfBlock;
nonterminal ForStatement ForStatement;
nonterminal DesignatorStatementList DesignatorStatementList;
nonterminal LastSingleVar LastSingleVar;
nonterminal LastFormParam LastFormParam;
terminal PROG, NAMESPACE, LBRACE, RBRACE;
terminal BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ,RETURN, VOID, EXTENDS, CONTINUE, FOR, STATIC;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, NOTEQUAL, GRT, GRTE, LSS, LSSE, BITAND, BITOR, ASSIGN, PLUSPLUS, MINUSMINUS;
terminal SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE, LAMBDA;

terminal String IDENT;
terminal Integer NUMCONST;
terminal Boolean BOOLCONST;
terminal Character CHARCONST;

precedence left ELSE;

Program ::= (Program) PROG ProgName:p NamespaceList:N1 DeclarationList:D2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new Program(p, N1, D2, M3); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

NamespaceList ::= (Namespaces) NamespaceList:N1 Namespace:N2 {: RESULT=new Namespaces(N1, N2); RESULT.setLine(N1left); :}
                |
                (NoNamespace) {: RESULT=new NoNamespace(); :} /* epsilon */
                ;

Namespace ::= (Namespace) NAMESPACE NamespaceName:N1 LBRACE DeclarationList:D2 LBRACE MethodDeclList:M3 RBRACE RBRACE {: RESULT=new Namespace(N1, D2, M3); RESULT.setLine(N1left); :};

NamespaceName ::= (NamespaceName) IDENT:NamespaceName {: RESULT=new NamespaceName(NamespaceName); RESULT.setLine(NamespaceNameleft); :};

ClassDecl ::= (ClassDecl) CLASS IDENT:I1 OptionalExtends:O2
                LBRACE
                StaticVarDeclList:S3
                StaticInitializerHelper:S4
                VarDeclList:V5
                OtpionalMethodDeclList:O6
                RBRACE {: RESULT=new ClassDecl(I1, O2, S3, S4, V5, O6); RESULT.setLine(I1left); :}
                ;

OptionalExtends ::= (Extends) EXTENDS Type:T1 {: RESULT=new Extends(T1); RESULT.setLine(T1left); :}
                |
                (NoExtends) {: RESULT=new NoExtends(); :} /* epsilon */
                ;

StaticVarDeclList ::= (StaticVarDecls) StaticVarDeclList:S1 STATIC VarDecl:V2 {: RESULT=new StaticVarDecls(S1, V2); RESULT.setLine(S1left); :}
                    |
                    (NoStaticVarDecl) {: RESULT=new NoStaticVarDecl(); :} /* epsilon */
                    ;

StaticInitializerHelper ::= (StaticInitializerHelperYes) StaticInitializerList:S1 {: RESULT=new StaticInitializerHelperYes(S1); RESULT.setLine(S1left); :} | (StaticInitializerHelperNo) {: RESULT=new StaticInitializerHelperNo(); :} /* epsilon */;

StaticInitializerList ::= (StaticInitializers) StaticInitializerList:S1 StaticInitializer:S2 {: RESULT=new StaticInitializers(S1, S2); RESULT.setLine(S1left); :}
                    |
                    (StaticInitializerSingle) StaticInitializer:S1 {: RESULT=new StaticInitializerSingle(S1); RESULT.setLine(S1left); :}
                    ;

StaticInitializer ::= (StaticInitializer) STATIC LBRACE StatementList:S1 RBRACE {: RESULT=new StaticInitializer(S1); RESULT.setLine(S1left); :};//mozda bude bacalo konflikt

OtpionalMethodDeclList ::= (OptionalMethodDecls) LBRACE MethodDeclList:M1 RBRACE {: RESULT=new OptionalMethodDecls(M1); RESULT.setLine(M1left); :}
                        |
                        (NoOptionalMethodDecl) {: RESULT=new NoOptionalMethodDecl(); :} /* epsilon */
                        ;

MethodDeclList ::= (MethodDecls) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDecls(M1, M2); RESULT.setLine(M1left); :}
                |
                (NoMethodDecl) {: RESULT=new NoMethodDecl(); :} /* epsilon */
                ;

MethodDecl ::= (MethodDecl) MethodTypeName:M1 LPAREN PossibleFormPars:P2 RPAREN VarDeclList:V3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDecl(M1, P2, V3, S4); RESULT.setLine(M1left); :};

MethodTypeName ::= (MethodWithType) Type:T1 IDENT:methodName {: RESULT=new MethodWithType(T1, methodName); RESULT.setLine(T1left); :} | (VoidMethod) VOID IDENT:methodName {: RESULT=new VoidMethod(methodName); RESULT.setLine(methodNameleft); :};

PossibleFormPars ::= (PossibleFormParsDeclared) FormPars:F1 {: RESULT=new PossibleFormParsDeclared(F1); RESULT.setLine(F1left); :}
                |
                (NoPossibleFormPars) {: RESULT=new NoPossibleFormPars(); :} /* epsilon */
                ;

FormPars ::= (FormParsList) FormPars:F1 COMMA LastFormParam:L2 {: RESULT=new FormParsList(F1, L2); RESULT.setLine(F1left); :}
            |
            (SignleFromParam) FormParam:F1 {: RESULT=new SignleFromParam(F1); RESULT.setLine(F1left); :}
            ;

LastFormParam ::= (LastFormParamCorrect) Type:tip IDENT:paramName PossibleArrayDecl:possibleArray {: RESULT=new LastFormParamCorrect(tip, paramName, possibleArray); RESULT.setLine(tipleft); :}
            |
            (LastFormParamError) error:l
            {: parser.report_error("Izvrsen oporavak do ) u liniji " +lleft, null); :} {: RESULT=new LastFormParamError(); :}
            ;

FormParam ::= (FormParamCorrect) Type:tip IDENT:paramName PossibleArrayDecl:possibleArray {: RESULT=new FormParamCorrect(tip, paramName, possibleArray); RESULT.setLine(tipleft); :}
            |
            (FormParamError) error:l
            {: parser.report_error("Izvrsen oporavak do , u liniji " +lleft, null); :} {: RESULT=new FormParamError(); :}
            ;

PossibleArrayDecl ::= (PossibleArrayDeclYes)  LSQUARE RSQUARE {: RESULT=new PossibleArrayDeclYes(); :} | (NoPossibleArrayDecl) {: RESULT=new NoPossibleArrayDecl(); :} /* epislon */;

DeclarationList ::= (DeclarationListVarDecl) DeclarationList:D1 VarDecl:V2 {: RESULT=new DeclarationListVarDecl(D1, V2); RESULT.setLine(D1left); :}
			|
			(DeclarationListConstDecl) DeclarationList:D1 ConstDecl:C2 {: RESULT=new DeclarationListConstDecl(D1, C2); RESULT.setLine(D1left); :}
			|
			(DeclarationListClassDecl) DeclarationList:D1 ClassDecl:C2 {: RESULT=new DeclarationListClassDecl(D1, C2); RESULT.setLine(D1left); :}
			|
			(NoDeclarationList) {: RESULT=new NoDeclarationList(); :}/* epsilon */
			;

VarDeclList ::= (VarDecls) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDecls(V1, V2); RESULT.setLine(V1left); :}
                |
                (NoVarDecl) {: RESULT=new NoVarDecl(); :} /* epsilon */
                ;

VarDecl ::= (VarDecl) Type:varType MultipleVarDecl:mulitpleVars SEMI {: RESULT=new VarDecl(varType, mulitpleVars); RESULT.setLine(varTypeleft); :}
                ;

MultipleVarDecl ::= (MultipleVarDecls) MultipleVarDecl:M1 COMMA LastSingleVar:L2 {: RESULT=new MultipleVarDecls(M1, L2); RESULT.setLine(M1left); :}
                |
                (MultipleVarDeclSingleVar) SingleVar:S1 {: RESULT=new MultipleVarDeclSingleVar(S1); RESULT.setLine(S1left); :}
                ;

LastSingleVar ::= (LastSingleVarCorrect) IDENT:varName PossibleArrayDecl:possibleArray {: RESULT=new LastSingleVarCorrect(varName, possibleArray); RESULT.setLine(varNameleft); :}
                |
                (LastSingleVarError) error:l
                {: parser.report_error("Izvrsen oporavak do ; u liniji " +lleft, null); :} {: RESULT=new LastSingleVarError(); :}
                ;

SingleVar ::= (SingleVarCorrect) IDENT:varName PossibleArrayDecl:possibleArray {: RESULT=new SingleVarCorrect(varName, possibleArray); RESULT.setLine(varNameleft); :}
            |
            (SingleVarError) error:l
            {: parser.report_error("Izvrsen oporavak do , u liniji " +lleft, null); :} {: RESULT=new SingleVarError(); :}
            ;

Type ::= (TypeWNamespace) IDENT:namespace COLON COLON IDENT:typeName {: RESULT=new TypeWNamespace(namespace, typeName); RESULT.setLine(namespaceleft); :}
        |
        (NormalType) IDENT:typeName {: RESULT=new NormalType(typeName); RESULT.setLine(typeNameleft); :}
        ;

ConstDecl ::= (ConstDecl) CONST Type:T1 IDENT:constName ASSIGN Literal:literal MultipleConstDecl:M2 SEMI {: RESULT=new ConstDecl(T1, constName, literal, M2); RESULT.setLine(T1left); :};

MultipleConstDecl ::= (MultipleConstDecls) MultipleConstDecl:M1 COMMA IDENT:constName ASSIGN Literal:literal {: RESULT=new MultipleConstDecls(M1, constName, literal); RESULT.setLine(M1left); :}
                    |
                    (NoMultipleConst) {: RESULT=new NoMultipleConst(); :} /* epsilon */
                    ;

Literal ::= (LiteralNUM) NUMCONST:value {: RESULT=new LiteralNUM(value); RESULT.setLine(valueleft); :} | (LiteralBOOL) BOOLCONST:value {: RESULT=new LiteralBOOL(value); RESULT.setLine(valueleft); :} | (LiteralCHAR) CHARCONST:value {: RESULT=new LiteralCHAR(value); RESULT.setLine(valueleft); :};

StatementList ::= (Statements) StatementList:S1 Statement:S2 {: RESULT=new Statements(S1, S2); RESULT.setLine(S1left); :}
                |
                (NoStatement) {: RESULT=new NoStatement(); :} /* epsilon */
                ;

Statement ::=  (StatementWDesignatorStmt) DesignatorStatement:D1 SEMI {: RESULT=new StatementWDesignatorStmt(D1); RESULT.setLine(D1left); :}
            |
            (IfStatement) IfBlock:I1 {: RESULT=new IfStatement(I1); RESULT.setLine(I1left); :}
            |
            (IfElseStatement) IfBlock:I1 ELSE Statement:S2 {: RESULT=new IfElseStatement(I1, S2); RESULT.setLine(I1left); :}
            |
            (StatementBreak) BREAK SEMI {: RESULT=new StatementBreak(); :}
            |
            (StatementContinue) CONTINUE SEMI {: RESULT=new StatementContinue(); :}
            |
            (StatementRetrun) RETURN SEMI {: RESULT=new StatementRetrun(); :}
            |
            (StatementReturnExpr) RETURN Expr:E1 SEMI {: RESULT=new StatementReturnExpr(E1); RESULT.setLine(E1left); :}
            |
            (StatementRead) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new StatementRead(D1); RESULT.setLine(D1left); :}
            |
            (StatementPrintSingle) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new StatementPrintSingle(E1); RESULT.setLine(E1left); :}
            |
            (StatementPrintMultiple) PRINT LPAREN Expr:E1 COMMA NUMCONST:N2 RPAREN SEMI {: RESULT=new StatementPrintMultiple(E1, N2); RESULT.setLine(E1left); :}
            |
            (StatementForLoop) ForLoopStart:F1 LPAREN PossibleDesignatorStatementList:P2 ForConditionStart:F3 PossibleCondFact:P4 ForTailDesignatorStart:F5 PossibleDesignatorStatementList:P6 ForStatementsStart:F7 ForStatement:F8 {: RESULT=new StatementForLoop(F1, P2, F3, P4, F5, P6, F7, F8); RESULT.setLine(F1left); :}
            |
            (StatementStmtList) LBRACE StatementListDetected:S1 StatementList:S2 RBRACE {: RESULT=new StatementStmtList(S1, S2); RESULT.setLine(S1left); :}
            ;
//all helpert for if-else
IfStartDetected ::= (IfStartDetected) IF {: RESULT=new IfStartDetected(); :};

IfConditionEndDetected ::= (IfConditionEndDetectedCorrect) IfStartDetected:I1 LPAREN Condition:C2 RPAREN {: RESULT=new IfConditionEndDetectedCorrect(I1, C2); RESULT.setLine(I1left); :}
                        |
                        (IfConditionError) IfStartDetected:I1 LPAREN error:l {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :} RPAREN {: RESULT=new IfConditionError(I1); RESULT.setLine(I1left); :}
                        ;

IfBlock ::= (IfBlock) IfConditionEndDetected:I1 Statement:S2 {: RESULT=new IfBlock(I1, S2); RESULT.setLine(I1left); :};

StatementListDetected ::= (StatementListDetected) {: RESULT=new StatementListDetected(); :} /*epsilon*/;

ForLoopStart ::= (ForLoopStart) FOR {: RESULT=new ForLoopStart(); :};

ForConditionStart ::= (ForConditionStart) SEMI {: RESULT=new ForConditionStart(); :};

ForStatementsStart ::= (ForStatementsStart) RPAREN {: RESULT=new ForStatementsStart(); :};

ForStatement ::= (ForStatement) Statement:S1 {: RESULT=new ForStatement(S1); RESULT.setLine(S1left); :};

ForTailDesignatorStart ::= (ForTailDesignatorStart) SEMI {: RESULT=new ForTailDesignatorStart(); :};

PossibleCondFact ::= (PossibleCondFactYes) CondFact:C1 {: RESULT=new PossibleCondFactYes(C1); RESULT.setLine(C1left); :} | (PossibleCondFactNo) {: RESULT=new PossibleCondFactNo(); :} /* epsilon */;

DesignatorStatementList ::= (DesignatorStatements) DesignatorStatementList:D1 COMMA DesignatorStatement:D2 {: RESULT=new DesignatorStatements(D1, D2); RESULT.setLine(D1left); :}
                                    |
                                    (SingleDesignatorStatement) DesignatorStatement:D1 {: RESULT=new SingleDesignatorStatement(D1); RESULT.setLine(D1left); :}
                                    ;

PossibleDesignatorStatementList ::= (PossibleDesignatorStatementListYes) DesignatorStatementList:D1 {: RESULT=new PossibleDesignatorStatementListYes(D1); RESULT.setLine(D1left); :} | (PossibleDesignatorStatementListNo) {: RESULT=new PossibleDesignatorStatementListNo(); :} /* epsilon*/ ;

DesignatorStatement ::= (DesignatorStmtAssign) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorStmtAssign(D1, A2, E3); RESULT.setLine(D1left); :}
                    |
                    (DesignatorStatementError) error:l
                    {: parser.report_error("Izvrsen oporavak do ; u liniji " +lleft, null); :} {: RESULT=new DesignatorStatementError(); :}
                    |
                    (DesignatorStmtCallNoArg) Designator:D1 LPAREN RPAREN {: RESULT=new DesignatorStmtCallNoArg(D1); RESULT.setLine(D1left); :}
                    |
                    (DesignatorStmtCallArg) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new DesignatorStmtCallArg(D1, A2); RESULT.setLine(D1left); :}
                    |
                    (DesignatorStmtPlusPlus) Designator:D1 PLUSPLUS {: RESULT=new DesignatorStmtPlusPlus(D1); RESULT.setLine(D1left); :}
                    |
                    (DesignatorStmtMinusMinus) Designator:D1 MINUSMINUS {: RESULT=new DesignatorStmtMinusMinus(D1); RESULT.setLine(D1left); :}
                    |
                    (DesignatorStatementMultipleAssign) LSQUARE DesStmtHelper:D1 MUL Designator:lastLeft RSQUARE ASSIGN Designator:rightDes {: RESULT=new DesignatorStatementMultipleAssign(D1, lastLeft, rightDes); RESULT.setLine(D1left); :}
                    ;

DesStmtHelper ::= (DesStmtHelperYes) DesStmtHelper:D1 PossibleDesignator:des COMMA {: RESULT=new DesStmtHelperYes(D1, des); RESULT.setLine(D1left); :}
                |
                (DesStmtHelperNo) {: RESULT=new DesStmtHelperNo(); :} /* epsilon */
                ;

PossibleDesignator ::= (DesignatorYes) Designator:D1 {: RESULT=new DesignatorYes(D1); RESULT.setLine(D1left); :} | (DesignatorNo) {: RESULT=new DesignatorNo(); :} /* epsilon*/;

ActPars ::= (ActParams) ActPars:A1 COMMA Expr:e {: RESULT=new ActParams(A1, e); RESULT.setLine(A1left); :}
        |
        (ActParam) Expr:e {: RESULT=new ActParam(e); RESULT.setLine(eleft); :}
        ;

Condition ::= (ConditionBITOR) ORBlockDetected:O1 BITOR CondTerm:C2 {: RESULT=new ConditionBITOR(O1, C2); RESULT.setLine(O1left); :}
            |
            (NormalCondition) CondTerm:C1 {: RESULT=new NormalCondition(C1); RESULT.setLine(C1left); :}
            ;

ORBlockDetected ::= (ORBlockDetected) Condition:C1 {: RESULT=new ORBlockDetected(C1); RESULT.setLine(C1left); :};

CondTerm ::= (CondTermBITAND) CondTerm:C1 BITAND CondFact:C2 {: RESULT=new CondTermBITAND(C1, C2); RESULT.setLine(C1left); :}
            |
            (NormalCondTerm) CondFact:C1 {: RESULT=new NormalCondTerm(C1); RESULT.setLine(C1left); :}
            ;


CondFact ::= (NormalCondFact) Expr:e {: RESULT=new NormalCondFact(e); RESULT.setLine(eleft); :}
            |
            (RelopCondFact) Expr:e1 Relop:R1 Expr:e2 {: RESULT=new RelopCondFact(e1, R1, e2); RESULT.setLine(e1left); :}
            ;

Expr ::= (GeneralExpr) Expr:e Addop:A1 Term:t {: RESULT=new GeneralExpr(e, A1, t); RESULT.setLine(eleft); :}
        |
        (ExprMinusTerm) MINUS Term:t {: RESULT=new ExprMinusTerm(t); RESULT.setLine(tleft); :}
        |
        (ExprTerm) Term:t {: RESULT=new ExprTerm(t); RESULT.setLine(tleft); :}
        ;

Term ::= (TermMulop) Term:term Mulop:M1 Factor:fac {: RESULT=new TermMulop(term, M1, fac); RESULT.setLine(termleft); :}//multiplication
        |
        (TermFactor) Factor:fac {: RESULT=new TermFactor(fac); RESULT.setLine(facleft); :}
        ;

Factor ::= (FactorDesignator) Designator:des {: RESULT=new FactorDesignator(des); RESULT.setLine(desleft); :}
        |
        (FactorCall) Designator:des LPAREN FactorCallPossiblePars:possPars RPAREN {: RESULT=new FactorCall(des, possPars); RESULT.setLine(desleft); :}
        |
        (FactorNum) NUMCONST:numValue {: RESULT=new FactorNum(numValue); RESULT.setLine(numValueleft); :}
        |
        (FactorChar) CHARCONST:charValue {: RESULT=new FactorChar(charValue); RESULT.setLine(charValueleft); :}
        |
        (FactorBool) BOOLCONST:boolValue {: RESULT=new FactorBool(boolValue); RESULT.setLine(boolValueleft); :}
        |
        (FactorNewArrayExpr) NEW Type:T1 LSQUARE Expr:expr RSQUARE {: RESULT=new FactorNewArrayExpr(T1, expr); RESULT.setLine(T1left); :}
        |
        (FactorNewFunctionParams) NEW Type:T1 LPAREN ActPars:A2 RPAREN {: RESULT=new FactorNewFunctionParams(T1, A2); RESULT.setLine(T1left); :}
        |
        (FactorNewFunctionNoParams) NEW Type:T1 LPAREN RPAREN {: RESULT=new FactorNewFunctionNoParams(T1); RESULT.setLine(T1left); :}
        |
        (FactorParenExpr) LPAREN Expr:E1 RPAREN {: RESULT=new FactorParenExpr(E1); RESULT.setLine(E1left); :}
        ;

FactorCallPossiblePars ::= (FactorCallPossibleParsYes) ActPars:A1 {: RESULT=new FactorCallPossibleParsYes(A1); RESULT.setLine(A1left); :} | (FactorCallPossibleParsNo) {: RESULT=new FactorCallPossibleParsNo(); :} /* epsilon */;

Designator ::= (DesignatorWNamespace) IDENT:namespace COLON COLON IDENT:desName {: RESULT=new DesignatorWNamespace(namespace, desName); RESULT.setLine(namespaceleft); :}
            |
            (DesignatorWONamespace) IDENT:desName {: RESULT=new DesignatorWONamespace(desName); RESULT.setLine(desNameleft); :}
            |
            (DesignatorField) Designator:D1 DOT IDENT:fieldName {: RESULT=new DesignatorField(D1, fieldName); RESULT.setLine(D1left); :}
            |
            (DesignatorArray) DesignatorArrayName:D1 LSQUARE Expr:index RSQUARE {: RESULT=new DesignatorArray(D1, index); RESULT.setLine(D1left); :}
            ;

DesignatorArrayName ::= (DesignatorArrayName) Designator:D1 {: RESULT=new DesignatorArrayName(D1); RESULT.setLine(D1left); :};

Label ::= (Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};

Assignop ::= (Assignop) ASSIGN {: RESULT=new Assignop(); :}
        ;

Relop ::= (RelopEQUAL) EQUAL {: RESULT=new RelopEQUAL(); :}
        |
        (RelopNOTEQUAL) NOTEQUAL {: RESULT=new RelopNOTEQUAL(); :}
        |
        (RelopGRT) GRT {: RESULT=new RelopGRT(); :}
        |
        (RelopGRTE) GRTE {: RESULT=new RelopGRTE(); :}
        |
        (RelopLSS) LSS {: RESULT=new RelopLSS(); :}
        |
        (RelopLSSE) LSSE {: RESULT=new RelopLSSE(); :}
        ;

Addop ::= (AddopPLUS) PLUS {: RESULT=new AddopPLUS(); :} | (AddopMINUS) MINUS {: RESULT=new AddopMINUS(); :};

Mulop ::= (MulopMUL) MUL {: RESULT=new MulopMUL(); :} | (MulopDIV) DIV {: RESULT=new MulopDIV(); :} | (MulopMOD) MOD {: RESULT=new MulopMOD(); :} ;
